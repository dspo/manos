# 产品设计与实现计划：基于 gpui/gpui-component 的 Git 冲突解决工具

## 目标
- 提供 JetBrains 风格的文件变更与冲突解决体验：两栏/三栏 diff、逐块采纳、冲突导航、部分暂存。
- 性能优先：大文件/多冲突场景保持流畅，滚动与行高同步准确。
- 易扩展：后续可加入评论、PR 对比、AI 辅助等。

## 功能范围
- 最小可用（MVP）
  - 文件列表：显示修改/冲突文件，过滤冲突；点击打开 diff/三方视图。
  - 视图模式：二栏 unified/split；冲突文件提供三栏 ours/base/theirs 与合并结果。
  - 冲突块操作：逐块采纳 ours/theirs/base，允许手动编辑合并结果；上一/下一冲突导航；折叠未改动上下文。
  - Git 操作：stage/unstage 文件与 hunk；revert hunk；忽略空白开关。
  - 性能：行级虚拟化；双/三栏滚动同步；异步 diff/merge 计算。
- 进阶（后续）
  - 历史/任意 commit 对比；评论；键盘驱动操作；批量冲突解决；未解决计数提示；外部修改检测与重载。

## 阶段性总结（已实现）
- 已落地可运行二进制：`crates/git-viewer`（`cargo run -p git-viewer`）。
- Git 操作当前全部通过 **系统 `git` CLI** 完成（`std::process::Command`）：`status/show/add/reset/apply` 等；暂未引入 `libgit2`/`gix`。
- 启动降级：启动时探测 `git` 是否可执行；缺失时提示并禁用仓库状态与 Git 操作（demo 可用）。
- Diff 视图：Split/Inline；Split 支持“对齐”与“真分栏（多 pane + 同步滚动）”；支持折叠上下文、忽略空白、hunk 导航。
- 工具条：Diff/Conflict 工具条使用 Popover 收纳“对比目标/更多操作（视图/保存/Git）”，在小窗口下仍可完整操作。
- 快捷键（基础）：Esc 返回；Alt+N/P 导航；Alt+W 忽略空白；Alt+V 切换视图；Alt+L 切换对齐/分栏；Cmd/Ctrl+S 保存冲突结果（冲突清零后）。
- 性能与体验（基础版）：git/IO/diff 计算移到 `background_executor`；忽略空白/上下文改动采用 120ms 防抖 + 后台重算；虚拟列表 `item_sizes` 缓存减少大向量分配；切换 Split/Inline 复用 diff model 仅重建行列表；提供 Large Diff Demo（`GIT_VIEWER_LARGE_DEMO_LINES`）。
- 对比目标：支持 `HEAD↔工作区 / 暂存↔工作区 / HEAD↔暂存` 切换，作为部分暂存/撤销的语义基础。
- 任意 refs/历史对比：Diff 页“对比”Popover 内支持输入 `HEAD~1/a1b2c3/INDEX/:/WORKTREE` 等 refs；并提供“从历史选择 commit…”弹窗（`git log -- <path>`），可在 `parent→commit` 与 `commit→工作区` 两种模式间切换。
- Git 操作：文件级 stage/unstage；当前 hunk 级 stage/unstage/revert（patch 生成 + `git apply`）。
- 冲突：支持 marker 解析（含 diff3 base），冲突块操作与保存/`git add` 的闭环；分栏模式下可显示 Ours/Base/Theirs；底部“合并结果”编辑器可手动修改并点击“应用”刷新冲突检测；状态栏显示未解决计数。
- 体验：工具条使用 `flex-wrap`，在窄窗口下仍能操作（并减少 debug 信息密度）。
- CommandPalette：`Cmd/Ctrl+K` 或 `Cmd/Ctrl+Shift+P` 打开命令面板，支持搜索并执行常用命令（导航、切换视图/布局/空白、展开折叠、打开历史对比、冲突保存等）。

## 交互与布局（核心视图）
- 左侧：仓库文件列表 + 过滤（全部/冲突/已暂存/未暂存）；文件状态徽标。
- 主区：根据模式渲染
  - 双栏 split：左右各一滚动容器，双 gutter 行号与变更类型，内联差异高亮，工具条（忽略空白、折叠上下文、复制原/新、重置块）。
  - 单栏 inline：合并后的行流，行内添加/删除标记。
  - 三栏冲突：ours/base/theirs + 合并结果（可与 ours/theirs并列或单独结果栏），冲突块顶部显示来源，提供采纳按钮。
- 辅助：顶部摘要（冲突计数、已解决/未解决），右侧标尺标记冲突/变更，底部状态条（Git 状态、行列位置）。

## 技术架构
- 文本与 diff
  - Rope 文本模型：复用 Zed 的 buffer 或使用 `ropey`；支持增量编辑。
  - Diff/merge：`similar` 做二方 diff，三方 merge 可用 `merge`/`similar::Algorithm::Lcs` 或复用 Zed 的三方合并逻辑；支持忽略空白选项。
  - 内联差异：基于 diff 片段生成 span metadata（added/removed/unchanged/conflict-origin）。
  - 虚拟化：按可视区域+预加载行窗口渲染，缓存布局；大文件防抖 resize/reflow。
- UI 组件（gpui/gpui-component）
  - 滚动容器 + 共享 scroll model 实现双/三栏同步。
  - Gutter 组件：行号、变更标记、冲突标记；可点击跳转。
  - Diff 行组件：接受 span metadata 与样式；支持折叠上下文。
  - 工具条组件：模式切换、忽略空白、折叠、上一/下一冲突、采纳按钮。
- 状态管理
  - RepoState：工作区根、git 状态（unstaged/staged/conflicts/untracked）。
  - DiffState：当前文件的左右/三方文档、模式、忽略空白、折叠状态、滚动同步状态。
  - ConflictBlock：标识 ours/theirs/base 范围、可采纳操作、解决状态。
  - 视图偏好持久化（可选）。
- Git 集成
  - 当前实现采用系统 `git` CLI（`Command`），优先复用 git 的成熟行为与边界条件处理（尤其是部分暂存/反向应用补丁）。
  - 已覆盖：`git status --porcelain=v2 -z`、`git show HEAD:<path>`、`git show :<path>`（暂存区）、`git add`、`git reset HEAD --`、`git apply`（含 `--cached` 与 `-R`）。
  - 局部暂存：基于 diff hunk 生成 unified patch，stage 走 `git apply --cached`，unstage 走 `git apply -R --cached`，revert 走 `git apply -R`。
  - 未来可选：引入 `gix`/`libgit2`，用于减少对外部 git 的依赖、增强跨平台与错误结构化，但需要对齐 CLI 行为与补丁应用语义。

## 如果系统没有 `git` 命令：能否用纯 Rust？
结论：可以做到“足够可用”，但要做成 **JetBrains/CLI 同等语义**（尤其是 hunk 级暂存/反向应用补丁）难度较高，建议分层渐进。

- 可选技术路线
  - `gix`（gitoxide，纯 Rust）：读取对象/索引/工作区、计算 status/diff 能力强，适合做“无 git 二进制”的后备实现。
  - `git2`（libgit2 绑定，非纯 Rust）：无需系统 `git`，但引入 C 依赖与平台构建复杂度；优势是生态成熟、API 稳定。
- 哪些能力容易纯 Rust 化
  - 仓库发现（repo root）、读取 `HEAD`/任意 commit 的文件内容（blob）、读取 index 版本、基础 status（已暂存/未暂存/未跟踪/冲突）。
  - 冲突解决写回：写工作区文件 + 更新 index（整文件 `add`）。
- 哪些能力在纯 Rust 下更难（也是我们当前优先用 CLI 的原因）
  - **hunk/行级暂存与撤销**：CLI 走 `git apply (--cached/-R)`，涉及 fuzz、上下文匹配、换行/CRLF、空白规则等细节；要做到与 CLI 一致，需要实现/复用等价的补丁应用器并覆盖大量边界。
  - 与用户现有 Git 配置/钩子/属性（attributes、eol、submodule、rename 等）一致性：纯 Rust 后端需要显式对齐。
- 推荐的工程策略（兼顾可用与可维护）
  - 抽象 `GitBackend`（CLI / gix / git2）：默认用 CLI；启动时探测 `git` 是否可执行。
  - 当缺少 `git`：
    - 优先：使用 `gix`/`git2` 提供 read-only diff + 冲突解决（整文件保存与整文件 stage）。
    - 暂缓：hunk 级 stage/unstage/revert（可在 UI 上灰掉，并在提示里说明需要 `git` 或启用对应后端能力）。

## 实现步骤（建议迭代）
1) 基础设施
   - 搭建 gpui 应用骨架，建立 RepoState + 异步 git service（拉取 status/diff）。
   - 引入 rope 文本模型，封装文档加载与行访问接口。
2) 二方 diff 视图（无冲突）
   - 实现 diff 计算（忽略空白开关）与 hunk 模型。
   - 构建 split 视图：双滚动容器、行虚拟化、gutter 标记、内联差异高亮、折叠上下文。
   - 内联视图：单容器流式渲染同一 hunk。
3) 冲突三方视图
   - 三方 merge 计算：生成冲突块，包含 ours/theirs/base/merged 区段。
   - 交互：逐块采纳 ours/theirs/base/混合编辑；上一/下一冲突导航；已解决计数。
   - 三栏行高/滚动同步，结果栏可编辑。
4) Git 操作集成
   - stage/unstage 文件与 hunk；revert hunk；重新加载状态。
   - 冲突解决完成后标记文件为已解决（写回合并结果并 `git add`）。
5) 性能与体验
   - 优化虚拟化窗口、布局缓存；防抖 resize；大文件流畅度测试。
   - 辅助标尺/摘要、键盘导航（可插拔命令表）。
6) 进阶能力（按需）
   - 历史/任意 commit 对比；评论；多仓库；外部修改检测与 reload。

## 技术细项与取舍
- 滚动同步：使用共享 scroll offset + 行高缓存；变更折叠时重新对齐。
- 折叠上下文：按 hunk 周围 N 行显示，可展开/收起；折叠状态存储在 DiffState。
- 语法高亮：复用 gpui rich text/Tree-sitter 管线，为 span 叠加 diff 样式。
- 键盘/命令：定义命令表（jump next conflict, accept ours/theirs, toggle whitespace）。
- 错误与安全：外部修改检测；冲突未解决时阻止保存或提示。

## 验收与测试
- 用小/中/大文件测试 diff、滚动同步、折叠、忽略空白。
- 构造冲突样例覆盖：仅 ours、仅 theirs、双改同一行、插入/删除交错。
- Git 操作回归：stage/unstage/hunk apply/revert；错误时保留缓冲区并提示。
- 性能基线：1-5 万行文件、10+ 冲突块保持流畅交互。
