use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let fonts_dir = manifest_dir.join("assets/fonts");
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let out_file = out_dir.join("embedded_fonts.rs");

    let mut font_files = Vec::new();
    if let Ok(entries) = fs::read_dir(&fonts_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if is_font_file(&path) {
                if let Some(name) = path.file_name().and_then(|name| name.to_str()) {
                    font_files.push(name.to_string());
                    println!("cargo:rerun-if-changed={}", path.display());
                }
            }
        }
    }

    font_files.sort();

    let mut output = String::new();
    output.push_str("// @generated by crates/git-viewer/build.rs\n");
    output.push_str("pub const EMBEDDED_FONT_BYTES: &[&[u8]] = &[\n");
    for file in &font_files {
        output.push_str(
            "    include_bytes!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/assets/fonts/\", ",
        );
        write_string_literal(&mut output, file);
        output.push_str(")),\n");
    }
    output.push_str("];\n\n");
    output.push_str("#[allow(dead_code)]\n");
    output.push_str("pub const EMBEDDED_FONT_FILES: &[&str] = &[\n");
    for file in &font_files {
        output.push_str("    ");
        write_string_literal(&mut output, file);
        output.push_str(",\n");
    }
    output.push_str("];\n");

    let mut f = fs::File::create(&out_file).expect("create embedded_fonts.rs");
    f.write_all(output.as_bytes())
        .expect("write embedded_fonts.rs");

    println!("cargo:rerun-if-changed={}", fonts_dir.display());
}

fn is_font_file(path: &Path) -> bool {
    if !path.is_file() {
        return false;
    }
    let Some(ext) = path.extension().and_then(|ext| ext.to_str()) else {
        return false;
    };
    matches!(ext.to_ascii_lowercase().as_str(), "ttf" | "otf" | "ttc")
}

fn write_string_literal(out: &mut String, value: &str) {
    out.push('"');
    for ch in value.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            ch => out.push(ch),
        }
    }
    out.push('"');
}
